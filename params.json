{"body":"This is very much a work in progress. I intend to move individual points to more detailed posts as I elaborate on them.\r\n\r\n# Abstract\r\n\r\nA fractal architecture is an application architecture based on intercommunicating, loosely-coupled, repeating and self-contained units.\r\n\r\n# Maxims\r\n\r\n1. Decentralized over centralized\r\n2. Local over global\r\n3. (Verbs over nouns)\r\n\r\n# Tenets\r\n\r\n## State\r\n\r\nState is a necessary evil. It gets progressively worse as its scope increases, doubly so if it is mutable. However, pretending it simply doesn't exist is impractical. A fractal architecture embraces, contains and limits state.\r\n\r\nAll state should be contained in a store specific to some business concept. A typical example is users, but other kinds of stores can exist simultaneously.\r\n\r\n## Communication\r\n\r\nSince a fractal architecture-based application is effectively a number of bubbles of state communicating with each other, remote procedure calls end up making a lot more sense than representational state transfer.\r\n\r\nThe author also personally finds these APIs simpler to build and maintain compared to REST ones. Many things fit well into CRUD. Some things don't. Sometimes, you just end up shoehorning something onto REST; or the 'REST' API ends up being little more than methods addressed by URL and called using POST requests. \r\n\r\nThis is in essence very similar to the actor model of concurrency. Actors are typically smaller than the shards in a fractal architecture: the things being promoted to first class citizens are closer to E's vats than E's objects.\r\n\r\n# Benefits\r\n\r\n* Scaling both up and down easily. If your machines have temporary, ephemeral links to a particular store, and any other machine should be able to take their place near-instantly, it should also be easy to add and remove machines.\r\n* Data locality. Apps that are well suited to this design tend to have a lot of operations being on a particular store.\r\n* Ease of implementation. RPC methods tend to have short, obvious implementations, even when the verb does not clearly map to a CRUD operation. This tends to lead to easier to maintain code with less bugs in it.\r\n* Easier development, staging and production parity. While not being an excuse for not having proper testing and CI, even on developer's machines, using tools that are consistent makes it a lot easier to have a shorter feedback loop.\r\n* Performance. It's very hard to compete with an API server running queries on a small, local SQLite database.\r\n* Lower cost. This is a consequence of several factors:\r\n  * Data locality: cold data can be moved to high latency, high redundancy stores.\r\n  * Performance: higher performance means less machines meaning a lower hosting bill.\r\n\r\n# Downsides\r\n\r\n* Unfamiliarity. Because this is not the de facto standard of web servers translating requests into database operations, there is significantly less existing work to fall back on. That said, many of the tools being used should be quite familiar, e.g. SQLite.\r\n* Added complexities of a distributed system once more than one machine is required to handle the load.\r\n* Difficulty of dealing with shared data. There are at least three approaches to doing this, and it's not always obvious which one is superior. This is somewhat related to the complexities of a distributed system.\r\n* Complexity of data redundancy. Assuming nodes have ephemeral local storage, a node going down means the local store is lost. Either the individual nodes have fairly reliable local storage, or the long-term storage has to be updated sufficiently often for catastrophic failure in a node to not cause unacceptable data loss (or some combination of both). Taking snapshots of a store actively being written to is an open problem; perhaps filesystem snapshots can provide an answer to this, although it may not be satisfactory \r\n\r\n# Tools\r\n\r\nA myriad of tools can be used to accomplish these tasks, but some are more naturally suited to it than others. For example:\r\n\r\n* SQLite is a fantastic data store for use cases where you have a large number of small and mobile databases. It's highly performant to boot.\r\n* Event-loop based systems tend to be better suited to the high level of inter-node communication. The author has had personal successes with Twisted, which comes with an implementation nice full-duplex RPC mechanism called AMP, and a distributed computing/remote objects system called Perspective Broker.\r\n\r\nThe author is writing a framework for doing this using Twisted and Axiom, a simple object store over SQLite.\r\n\r\n# Further reading\r\n\r\nThe author has given [a presentation at PyCon ZA](https://www.youtube.com/watch?v=w75TAXYZnNs) on this subject.","tagline":"An alternative to classic multi-layered application architectures","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Fractal Architecture Manifesto"}